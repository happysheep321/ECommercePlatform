# 08_高级架构模式与实践 - 进阶学习指南

## 【学习目标】
通过本文档，您将学会：
- 理解领域事件驱动的架构设计
- 掌握工作单元模式的数据一致性管理
- 学会使用中间件进行横切关注点处理
- 理解Redis缓存的实践应用
- 掌握微服务架构中的高级设计模式
- 能够设计和实现可扩展的微服务架构

## 【领域事件驱动架构】

### 什么是领域事件？
领域事件就像现实世界中的**通知系统**：
- 当业务发生时，发布事件通知
- 其他服务可以订阅这些事件
- 实现服务间的松耦合通信
- 支持异步处理和事件溯源

### 核心概念

#### 1. 领域事件接口
```csharp
// 领域事件接口
public interface IDomainEvent : INotification
{
    DateTime OccurredOn { get; }  // 事件发生时间
}

// 具体领域事件示例
public class UserRoleAssignedEvent : IDomainEvent
{
    public Guid UserId { get; }
    public Guid RoleId { get; }
    public DateTime OccurredOn { get; } = DateTime.UtcNow;

    public UserRoleAssignedEvent(Guid userId, Guid roleId)
    {
        UserId = userId;
        RoleId = roleId;
    }
}
```

#### 2. 聚合根中的事件管理
```csharp
// 聚合根基类 - 事件管理
public abstract class EntityBase<TId> : Entity<TId>, IAggregateRoot
{
    private List<IDomainEvent>? domainEvents;
    
    // 只读的领域事件集合
    public IReadOnlyCollection<IDomainEvent>? DomainEvents => domainEvents?.AsReadOnly();

    // 添加领域事件
    public void AddDomainEvent(IDomainEvent domainEvent)
    {
        domainEvents ??= new List<IDomainEvent>();
        domainEvents.Add(domainEvent);
    }

    // 清空领域事件
    public void ClearDomainEvents()
    {
        domainEvents?.Clear();
    }
}

// 具体聚合根示例
public class User : EntityBase<Guid>
{
    private List<UserRole> _userRoles = new();
    
    public void AssignRole(Role role)
    {
        var userRole = new UserRole(Id, role.Id);
        _userRoles.Add(userRole);
        
        // 发布领域事件
        AddDomainEvent(new UserRoleAssignedEvent(Id, role.Id));
    }
}
```

#### 3. 事件分发器
```csharp
// 事件分发器接口
public interface IDomainEventDispatcher
{
    Task DispatchAsync(IDomainEvent domainEvent);
}

// 使用MediatR的事件分发器
public class MediatRDomainEventDispatcher : IDomainEventDispatcher
{
    private readonly IMediator mediator;

    public MediatRDomainEventDispatcher(IMediator mediator)
    {
        this.mediator = mediator;
    }

    public async Task DispatchAsync(IDomainEvent domainEvent)
    {
        await mediator.Publish(domainEvent);
    }
}
```

#### 4. DbContext中的事件处理
```csharp
public class IdentityDbContext : DbContext
{
    private readonly IDomainEventDispatcher? domainEventDispatcher;

    public IdentityDbContext(DbContextOptions<IdentityDbContext> options, IDomainEventDispatcher domainEventDispatcher) : base(options)
    {
        this.domainEventDispatcher = domainEventDispatcher;
    }

    public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        var result = await base.SaveChangesAsync(cancellationToken);

        // 获取所有继承自EntityBase<TId>的实体，并收集它们的领域事件
        var entitiesWithEvents = ChangeTracker.Entries<EntityBase<Guid>>()
            .Select(e => e.Entity)
            .Where(e => e.DomainEvents != null && e.DomainEvents.Any())
            .ToArray();

        // 派发所有领域事件
        foreach (var entity in entitiesWithEvents)
        {
            var events = entity.DomainEvents!.ToArray();
            foreach (var domainEvent in events)
            {
                await domainEventDispatcher!.DispatchAsync(domainEvent);
            }
            entity.ClearDomainEvents();
        }

        return result;
    }
}
```

### 事件处理器的实现
```csharp
// 事件处理器示例
public class UserRoleAssignedEventHandler : INotificationHandler<UserRoleAssignedEvent>
{
    private readonly ILogger<UserRoleAssignedEventHandler> logger;
    private readonly IEmailSender emailSender;

    public UserRoleAssignedEventHandler(ILogger<UserRoleAssignedEventHandler> logger, IEmailSender emailSender)
    {
        this.logger = logger;
        this.emailSender = emailSender;
    }

    public async Task Handle(UserRoleAssignedEvent notification, CancellationToken cancellationToken)
    {
        logger.LogInformation("用户 {UserId} 被分配了角色 {RoleId}", notification.UserId, notification.RoleId);
        
        // 发送邮件通知
        await emailSender.SendEmailAsync("admin@example.com", "角色分配通知", 
            $"用户 {notification.UserId} 被分配了角色 {notification.RoleId}");
    }
}
```

## 【工作单元模式】

### 什么是工作单元模式？
工作单元模式就像是一个**事务管理器**：
- 管理数据库事务的一致性
- 确保多个操作要么全部成功，要么全部失败
- 提供统一的数据提交接口
- 简化业务逻辑中的事务管理

### 实现示例

#### 1. 工作单元接口
```csharp
public interface IUnitOfWork
{
    Task<int> SaveChangesAsync(CancellationToken cancellationToken = default);
}
```

#### 2. 工作单元实现
```csharp
public class UnitOfWork : IUnitOfWork
{
    private readonly IdentityDbContext context;

    public UnitOfWork(IdentityDbContext context)
    {
        this.context = context;
    }

    public Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
    {
        return context.SaveChangesAsync(cancellationToken);
    }
}
```

#### 3. 在业务服务中使用
```csharp
public class UserService : IUserService
{
    private readonly IUserRepository userRepository;
    private readonly IRoleRepository roleRepository;
    private readonly IUnitOfWork unitOfWork;
    private readonly ILogger<UserService> logger;

    public UserService(IUserRepository userRepository, IRoleRepository roleRepository, 
        IUnitOfWork unitOfWork, ILogger<UserService> logger)
    {
        this.userRepository = userRepository;
        this.roleRepository = roleRepository;
        this.unitOfWork = unitOfWork;
        this.logger = logger;
    }

    public async Task<Guid> RegisterAsync(RegisterUserCommand command)
    {
        try
        {
            // 1. 业务验证
            if (await userRepository.ExistsByEmailAsync(command.Email))
                throw new InvalidOperationException("邮箱已存在");

            // 2. 创建用户
            var user = new User(command.UserName, command.Email);
            user.SetPassword(command.Password, passwordHasher);

            // 3. 添加到仓储
            await userRepository.AddAsync(user);

            // 4. 提交事务
            await unitOfWork.SaveChangesAsync();

            logger.LogInformation("用户 {UserId} 注册成功", user.Id);
            return user.Id;
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "用户注册失败");
            throw;
        }
    }
}
```

## 【中间件模式】

### 什么是中间件？
中间件就像是一个**请求处理管道**：
- 在请求到达控制器之前进行处理
- 在响应返回客户端之前进行处理
- 处理横切关注点（日志、认证、异常等）
- 提供可插拔的功能模块

### 全局异常处理中间件

#### 1. 中间件实现
```csharp
public class GlobalExceptionMiddleware
{
    private readonly RequestDelegate next;
    private readonly ILogger<GlobalExceptionMiddleware> logger;

    public GlobalExceptionMiddleware(RequestDelegate next, ILogger<GlobalExceptionMiddleware> logger)
    {
        this.next = next;
        this.logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await next(context);
        }
        catch (UnauthorizedAccessException ex)
        {
            logger.LogWarning(ex, "Unauthorized: {Message}", ex.Message);
            await WriteResponse(context, HttpStatusCode.Unauthorized, 
                ApiResponse<string>.Fail("UNAUTHORIZED", ex.Message));
        }
        catch (ArgumentException ex)
        {
            logger.LogWarning(ex, "BadRequest: {Message}", ex.Message);
            await WriteResponse(context, HttpStatusCode.BadRequest, 
                ApiResponse<string>.Fail("BAD_REQUEST", ex.Message));
        }
        catch (InvalidOperationException ex)
        {
            logger.LogWarning(ex, "BusinessError: {Message}", ex.Message);
            await WriteResponse(context, HttpStatusCode.BadRequest, 
                ApiResponse<string>.Fail("BUSINESS_ERROR", ex.Message));
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "Unhandled exception");
            await WriteResponse(context, HttpStatusCode.InternalServerError, 
                ApiResponse<string>.Fail("INTERNAL_ERROR", "服务器内部错误"));
        }
    }

    private static async Task WriteResponse<T>(HttpContext context, HttpStatusCode statusCode, ApiResponse<T> body)
    {
        context.Response.ContentType = "application/json";
        context.Response.StatusCode = (int)statusCode;
        await context.Response.WriteAsJsonAsync(body);
    }
}
```

#### 2. 中间件扩展方法
```csharp
public static class GlobalExceptionMiddlewareExtensions
{
    public static IApplicationBuilder UseGlobalException(this IApplicationBuilder app)
    {
        return app.UseMiddleware<GlobalExceptionMiddleware>();
    }
}
```

#### 3. 在Program.cs中使用
```csharp
var app = builder.Build();

// 使用全局异常处理中间件
app.UseGlobalException();

// 其他中间件...
app.UseRouting();
app.UseAuthentication();
app.UseAuthorization();
```

### 应用构建器扩展
```csharp
public static class ApplicationBuilderExtensions
{
    public static IApplicationBuilder UseMicroserviceCommonMiddleware(
        this IApplicationBuilder app,
        IWebHostEnvironment env,
        bool enableSwagger = true,
        bool enableAuthentication = true,
        bool enableAuthorization = true)
    {
        app.UseRouting();

        // 全局异常统一返回
        app.UseGlobalException();

        if (enableAuthentication)
        {
            app.UseAuthentication();
        }

        if (enableAuthorization)
        {
            app.UseAuthorization();
        }

        if (enableSwagger && env.IsDevelopment())
        {
            app.UseSwagger();
            app.UseSwaggerUI();
        }

        app.UseEndpoints(endpoints =>
        {
            endpoints.MapControllers();
        });

        return app;
    }
}
```

## 【Redis缓存实践】

### Redis缓存的重要性
Redis缓存就像是一个**高速缓存**：
- 提高数据访问速度
- 减轻数据库压力
- 支持分布式缓存
- 提供多种数据结构

### Redis帮助类实现

#### 1. Redis接口
```csharp
public interface IRedisHelper
{
    Task SetAsync<T>(string key, T value, TimeSpan? expiry = null);
    Task<T?> GetAsync<T>(string key);
    Task DeleteAsync(string key);
}
```

#### 2. Redis实现（带超时控制）
```csharp
public class RedisHelper : IRedisHelper
{
    private readonly IDatabase database;
    private readonly TimeSpan defaultTimeout = TimeSpan.FromSeconds(10);

    public RedisHelper(IConnectionMultiplexer connectionMultiplexer)
    {
        database = connectionMultiplexer.GetDatabase();
    }

    public async Task SetAsync<T>(string key, T value, TimeSpan? expiry = null)
    {
        using var cts = new CancellationTokenSource(defaultTimeout);
        var json = JsonSerializer.Serialize(value);
        await database.StringSetAsync(key, json, expiry);
    }

    public async Task<T?> GetAsync<T>(string key)
    {
        using var cts = new CancellationTokenSource(defaultTimeout);
        var json = await database.StringGetAsync(key);
        if (json.IsNullOrEmpty)
        {
            return default;
        }
        return JsonSerializer.Deserialize<T>(json!);
    }

    public async Task DeleteAsync(string key)
    {
        using var cts = new CancellationTokenSource(defaultTimeout);
        await database.KeyDeleteAsync(key);
    }
}
```

### 缓存服务注册
```csharp
public static IServiceCollection AddRedisServices(
    this IServiceCollection services,
    IConfiguration configuration)
{
    var redisConnectionString = configuration.GetConnectionString("Redis");
    if (string.IsNullOrEmpty(redisConnectionString))
    {
        throw new InvalidOperationException("Redis connection string is missing");
    }

    services.AddSingleton<IConnectionMultiplexer>(sp =>
    {
        return ConnectionMultiplexer.Connect(redisConnectionString);
    });

    services.AddScoped<IRedisHelper, RedisHelper>();

    return services;
}
```

### 缓存应用示例

#### 1. 验证码服务
```csharp
public class EmailVerificationService : IVerificationCodeService
{
    private readonly IRedisHelper redisHelper;
    private readonly IEmailSender emailSender;
    private readonly ILogger<EmailVerificationService> logger;

    private const int CodeLength = 6;
    private const int ExpiryMinutes = 5;

    public EmailVerificationService(IRedisHelper redisHelper, IEmailSender emailSender, 
        ILogger<EmailVerificationService> logger)
    {
        this.redisHelper = redisHelper;
        this.emailSender = emailSender;
        this.logger = logger;
    }

    public async Task<bool> SendCodeAsync(string email)
    {
        try
        {
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(10));
            var code = GenerateCode(CodeLength);
            var key = GetRedisKey(email);

            // 将验证码存储到Redis，设置5分钟过期
            await redisHelper.SetAsync(key, code, TimeSpan.FromMinutes(ExpiryMinutes));
            
            logger.LogInformation($"验证码 {code} 已发送至 {email}，有效期 {ExpiryMinutes} 分钟。");
            return await emailSender.SendEmailAsync(email, "您的验证码", 
                $"您的验证码是：{code}，请在{ExpiryMinutes}分钟内使用。");
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "发送验证码失败: {Email}", email);
            throw new InvalidOperationException("验证码发送失败，请稍后重试");
        }
    }

    public async Task<bool> VerifyCodeAsync(string email, string code)
    {
        var key = GetRedisKey(email);
        var cachedCode = await redisHelper.GetAsync<string>(key);

        if (cachedCode == null || cachedCode != code)
        {
            return false;
        }

        // 验证成功后删除缓存
        await redisHelper.DeleteAsync(key);
        return true;
    }

    private static string GenerateCode(int length)
    {
        var random = new Random();
        var code = new StringBuilder();
        for (int i = 0; i < length; i++)
        {
            code.Append(random.Next(0, 10));
        }
        return code.ToString();
    }

    private static string GetRedisKey(string email)
    {
        return $"verification_code:{email}";
    }
}
```

#### 2. 用户信息缓存
```csharp
public class UserService : IUserService
{
    private readonly IUserRepository userRepository;
    private readonly IRedisHelper redisHelper;
    private readonly ILogger<UserService> logger;

    public UserService(IUserRepository userRepository, IRedisHelper redisHelper, 
        ILogger<UserService> logger)
    {
        this.userRepository = userRepository;
        this.redisHelper = redisHelper;
        this.logger = logger;
    }

    public async Task<UserProfileDto?> GetProfileAsync(Guid userId)
    {
        // 1. 尝试从缓存获取
        var cacheKey = $"user_profile:{userId}";
        var cachedProfile = await redisHelper.GetAsync<UserProfileDto>(cacheKey);
        
        if (cachedProfile != null)
        {
            logger.LogInformation("从缓存获取用户 {UserId} 资料", userId);
            return cachedProfile;
        }

        // 2. 从数据库获取
        var user = await userRepository.GetByIdAsync(userId);
        if (user == null)
            return null;

        var profile = new UserProfileDto
        {
            UserId = user.Id,
            UserName = user.UserName,
            Email = user.Email,
            PhoneNumber = user.PhoneNumber,
            NickName = user.Profile?.NickName,
            AvatarUrl = user.Profile?.AvatarUrl,
            Gender = (int)(user.Profile?.Gender ?? Gender.Unknown)
        };

        // 3. 存储到缓存（30分钟过期）
        await redisHelper.SetAsync(cacheKey, profile, TimeSpan.FromMinutes(30));
        
        logger.LogInformation("用户 {UserId} 资料已缓存", userId);
        return profile;
    }

    public async Task UpdateProfileAsync(Guid userId, UpdateUserProfileCommand command)
    {
        // 1. 更新数据库
        var user = await userRepository.GetByIdAsync(userId);
        if (user == null)
            throw new UnauthorizedAccessException("用户不存在");

        // 更新用户资料...
        await userRepository.Update(user);
        await unitOfWork.SaveChangesAsync();

        // 2. 清除缓存
        var cacheKey = $"user_profile:{userId}";
        await redisHelper.DeleteAsync(cacheKey);
        
        logger.LogInformation("用户 {UserId} 资料已更新，缓存已清除", userId);
    }
}
```

## 【微服务模板模式】

### 什么是微服务模板？
微服务模板就像是一个**标准化的启动模板**：
- 提供统一的微服务配置方式
- 减少重复代码
- 确保架构一致性
- 简化新服务的创建

### 微服务模板实现
```csharp
public static class MicroserviceTemplate
{
    public static WebApplication CreateMicroservice(
        string serviceName,
        string swaggerTitle,
        bool enableJwtAuth = false,
        bool enableRedis = false,
        Assembly? mediatRAssembly = null,
        Assembly? validatorAssembly = null,
        string[]? args = null)
    {
        var builder = WebApplication.CreateBuilder(args ?? Environment.GetCommandLineArgs());

        // 使用通用微服务配置
        builder.Services.AddMicroserviceCommonServices(
            configuration: builder.Configuration,
            serviceName: serviceName,
            swaggerTitle: swaggerTitle,
            enableJwtAuth: enableJwtAuth,
            enableRedis: enableRedis,
            mediatRAssembly: mediatRAssembly,
            validatorAssembly: validatorAssembly
        );

        builder.Host.UseSerilog();

        var app = builder.Build();

        Log.Information($"----------启动 {serviceName} 微服务----------");

        // 使用通用微服务中间件配置
        app.UseMicroserviceCommonMiddleware(builder.Environment);

        return app;
    }
}
```

### 使用模板创建微服务
```csharp
// Program.cs
var app = MicroserviceTemplate.CreateMicroservice(
    serviceName: "Product",
    swaggerTitle: "ECommerce.Product.API",
    enableJwtAuth: false,
    enableRedis: true,
    mediatRAssembly: Assembly.GetExecutingAssembly(),    // 自动发现所有Handler
    validatorAssembly: Assembly.GetExecutingAssembly()   // 自动发现所有验证器
);

app.Run();
```

## 【最佳实践总结】

### 1. 领域事件设计原则
- **事件命名**：使用过去时态，如 `UserRegistered`、`OrderConfirmed`
- **事件数据**：包含足够的信息供订阅者处理
- **事件粒度**：一个业务操作对应一个事件
- **事件顺序**：确保事件的处理顺序

### 2. 工作单元使用原则
- **单一职责**：一个工作单元处理一个业务事务
- **异常处理**：确保事务回滚
- **依赖注入**：通过DI容器管理工作单元生命周期
- **日志记录**：记录事务的开始和结束

### 3. 中间件设计原则
- **单一职责**：每个中间件只处理一个关注点
- **可配置性**：支持启用/禁用配置
- **性能考虑**：避免在中间件中进行耗时操作
- **错误处理**：提供统一的错误处理机制

### 4. 缓存策略
- **缓存键设计**：使用有意义的键名，如 `user_profile:{userId}`
- **过期时间**：根据数据更新频率设置合适的过期时间
- **缓存穿透**：对空值也进行缓存，避免频繁查询数据库
- **缓存更新**：在数据更新时及时清除相关缓存

### 5. 微服务设计原则
- **服务边界**：根据业务领域划分服务边界
- **数据隔离**：每个服务拥有自己的数据库
- **API设计**：提供RESTful API接口
- **监控日志**：完善的日志和监控体系

### 6. 超时处理与性能优化
- **网关超时**：设置合理的请求超时时间（30秒）
- **Redis超时**：为缓存操作添加超时控制（10秒）
- **数据库超时**：配置连接和命令超时时间
- **快速失败**：问题发生时快速返回错误，避免无限等待
- **依赖检查**：启动前检查所有依赖服务状态

## 【下一步】
接下来您可以：
1. **实践项目**：尝试在自己的项目中应用这些模式
2. **深入学习**：研究更多DDD和微服务架构模式
3. **性能优化**：学习如何优化微服务性能
4. **部署运维**：学习Docker、Kubernetes等部署技术

---

**学习提示：**
- 这些高级模式需要在实际项目中反复练习才能掌握
- 从简单的模式开始，逐步引入复杂的架构
- 关注性能影响，避免过度设计
- 保持代码的可读性和可维护性
