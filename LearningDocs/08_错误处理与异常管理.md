# 错误处理与异常管理指南

## 📖 概述

本文档详细介绍了ECommerce平台中的错误处理机制，包括验证错误、业务异常和系统异常的处理方式，以及如何将这些错误信息正确返回给前端。

## 🚨 错误处理架构

### 重要说明：ValidationException的正确使用

**⚠️ 常见问题：** 如果`message`为空，通常是因为`ValidationException`没有正确包含`Errors`集合。

**错误示例：**
```csharp
// ❌ 错误：只传递消息字符串，没有Errors集合
throw new ValidationException("验证失败");
```

**正确示例：**
```csharp
// ✅ 正确：传递ValidationFailure集合
throw new ValidationException(failures);
```

### 全局异常处理中间件

我们使用`GlobalExceptionMiddleware`来统一处理所有异常，确保错误信息能够正确返回给前端：

```csharp
public class GlobalExceptionMiddleware
{
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await next(context);
        }
        catch (ValidationException ex)
        {
            // 处理FluentValidation验证异常
            var errorMessages = ex.Errors.Select(e => e.ErrorMessage).ToList();
            var combinedMessage = string.Join("; ", errorMessages);
            
            await WriteResponse(context, HttpStatusCode.BadRequest, 
                ApiResponse<string>.Fail("VALIDATION_ERROR", combinedMessage));
        }
        catch (UnauthorizedAccessException ex)
        {
            // 处理认证异常
            await WriteResponse(context, HttpStatusCode.Unauthorized, 
                ApiResponse<string>.Fail("UNAUTHORIZED", ex.Message));
        }
        catch (ArgumentException ex)
        {
            // 处理参数异常
            await WriteResponse(context, HttpStatusCode.BadRequest, 
                ApiResponse<string>.Fail("BAD_REQUEST", ex.Message));
        }
        catch (InvalidOperationException ex)
        {
            // 处理业务逻辑异常
            await WriteResponse(context, HttpStatusCode.BadRequest, 
                ApiResponse<string>.Fail("BUSINESS_ERROR", ex.Message));
        }
        catch (Exception ex)
        {
            // 处理未预期的系统异常
            await WriteResponse(context, HttpStatusCode.InternalServerError, 
                ApiResponse<string>.Fail("INTERNAL_ERROR", "服务器内部错误"));
        }
    }
}
```

## ⏱️ 超时处理与性能优化

### 1. 网关超时配置

为了防止请求长时间挂起，我们在网关配置中设置了合理的超时时间：

```json
{
  "ReverseProxy": {
    "Clusters": {
      "identity": {
        "Destinations": {
          "d1": {
            "Address": "http://localhost:5101/"
          }
        },
        "HttpRequest": {
          "Timeout": "00:00:30"  // 30秒超时
        }
      }
    }
  }
}
```

### 2. Redis操作超时控制

为Redis操作添加超时控制，防止连接问题导致服务挂起：

```csharp
public class RedisHelper : IRedisHelper
{
    private readonly IDatabase database;
    private readonly TimeSpan defaultTimeout = TimeSpan.FromSeconds(10);

    public async Task<T?> GetAsync<T>(string key)
    {
        using var cts = new CancellationTokenSource(defaultTimeout);
        var json = await database.StringGetAsync(key);
        if (json.IsNullOrEmpty)
        {
            return default;
        }
        return JsonSerializer.Deserialize<T>(json!);
    }
}
```

### 3. 验证码服务超时处理

为验证码服务添加完整的超时和错误处理：

```csharp
public class EmailVerificationService : IVerificationCodeService
{
    private readonly TimeSpan operationTimeout = TimeSpan.FromSeconds(10);

    public async Task<bool> VerifyCodeAsync(string email, string code)
    {
        try
        {
            using var cts = new CancellationTokenSource(operationTimeout);
            var key = GetRedisKey(email);
            var cachedCode = await redisHelper.GetAsync<string>(key);

            if (cachedCode == null || cachedCode != code)
            {
                logger.LogWarning("验证码验证失败: {Email}, 输入码: {InputCode}, 缓存码: {CachedCode}", 
                    email, code, cachedCode ?? "null");
                return false;
            }

            await redisHelper.DeleteAsync(key);
            logger.LogInformation("验证码验证成功: {Email}", email);
            return true;
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "验证码验证过程中发生错误: {Email}", email);
            throw new InvalidOperationException("验证码验证失败，请稍后重试");
        }
    }
}
```

### 4. 数据库连接超时设置

为数据库连接字符串添加超时配置：

```json
{
  "ConnectionStrings": {
    "UserDb": "Server=localhost;Database=ECommerceIdentity;User Id=sa;Password=***;TrustServerCertificate=True;Connection Timeout=30;Command Timeout=30;",
    "Redis": "localhost:6379,connectTimeout=10000,syncTimeout=10000"
  }
}
```

### 5. 常见超时问题排查

#### 问题现象
- 请求长时间无响应
- 网关日志显示 `RequestTimedOut`
- 客户端收到 `TaskCanceledException`

#### 排查步骤
1. **检查依赖服务状态**：
   ```powershell
   netstat -an | findstr "5101\|6379\|1433"
   ```

2. **检查服务日志**：
   - 查看Identity服务日志
   - 查看Redis连接日志
   - 查看数据库连接日志

3. **验证超时配置**：
   - 确认网关超时设置
   - 确认Redis连接字符串
   - 确认数据库连接字符串

#### 解决方案
1. **启动依赖服务**：
   ```powershell
   # 启动Redis
   docker run -d -p 6379:6379 redis:latest
   
   # 启动SQL Server
   docker run -d -p 1433:1433 -e "SA_PASSWORD=***" mcr.microsoft.com/mssql/server:2019-latest
   ```

2. **重启微服务**：
   ```powershell
   # 重启Identity服务
   cd services/identity/ECommerce.Identity.API
   dotnet run
   
   # 重启网关
   cd gateway/ECommerce.APIGateway
   dotnet run
   ```

## 🔍 错误类型与处理

### 1. 验证错误 (ValidationException)

**触发场景：** FluentValidation验证失败时

**错误来源：**
- 用户输入数据不符合验证规则
- 业务规则验证失败

**示例：**
```csharp
// 验证器定义
public class UpdateUserProfileCommandValidator : AbstractValidator<UpdateUserProfileCommand>
{
    public UpdateUserProfileCommandValidator()
    {
        RuleFor(x => x.Gender)
            .InclusiveBetween(0, 2)
            .WithMessage("性别只能是 0（男）、1（女）或 2（未知）");
            
        RuleFor(x => x.Email)
            .EmailAddress()
            .When(x => !string.IsNullOrWhiteSpace(x.Email))
            .WithMessage("邮箱格式不正确");
    }
}
```

**前端收到的错误响应：**
```json
{
  "success": false,
  "code": "VALIDATION_ERROR",
  "message": "性别只能是 0（男）、1（女）或 2（未知）; 邮箱格式不正确",
  "data": null
}
```

### 2. 认证错误 (UnauthorizedAccessException)

**触发场景：** 用户未登录或权限不足

**错误来源：**
- 用户未提供有效的JWT Token
- Token已过期
- 用户权限不足

**示例：**
```csharp
// 在Controller中抛出认证异常
private Guid GetCurrentUserId()
{
    var userIdClaim = User.FindFirst(ClaimTypes.NameIdentifier);
    return userIdClaim != null ? Guid.Parse(userIdClaim.Value) : 
        throw new UnauthorizedAccessException("用户未认证");
}
```

**前端收到的错误响应：**
```json
{
  "success": false,
  "code": "UNAUTHORIZED",
  "message": "用户未认证",
  "data": null
}
```

### 3. 业务逻辑错误 (InvalidOperationException)

**触发场景：** 业务规则验证失败

**错误来源：**
- 邮箱已存在
- 用户状态不允许操作
- 业务约束条件不满足

**示例：**
```csharp
// 在Service中抛出业务异常
public async Task<Guid> RegisterAsync(RegisterUserCommand command)
{
    if (await userRepository.ExistsByEmailAsync(command.Email))
        throw new InvalidOperationException("邮箱已存在");
        
    // ... 其他业务逻辑
}
```

**前端收到的错误响应：**
```json
{
  "success": false,
  "code": "BUSINESS_ERROR",
  "message": "邮箱已存在",
  "data": null
}
```

### 4. 参数错误 (ArgumentException)

**触发场景：** 方法参数无效

**错误来源：**
- 必需参数为空
- 参数格式不正确
- 参数值超出范围

**示例：**
```csharp
public void UpdateUser(Guid userId, string userName)
{
    if (userId == Guid.Empty)
        throw new ArgumentException("用户ID不能为空", nameof(userId));
        
    if (string.IsNullOrWhiteSpace(userName))
        throw new ArgumentException("用户名不能为空", nameof(userName));
}
```

**前端收到的错误响应：**
```json
{
  "success": false,
  "code": "BAD_REQUEST",
  "message": "用户ID不能为空",
  "data": null
}
```

### 5. 系统错误 (Exception)

**触发场景：** 未预期的系统异常

**错误来源：**
- 数据库连接失败
- 外部服务调用失败
- 系统内部错误

**前端收到的错误响应：**
```json
{
  "success": false,
  "code": "INTERNAL_ERROR",
  "message": "服务器内部错误",
  "data": null
}
```

## 📋 错误响应格式

### 统一的错误响应结构

所有错误都使用统一的`ApiResponse<T>`格式：

```csharp
public class ApiResponse<T>
{
    public bool Success { get; set; }
    public string Code { get; set; }
    public string Message { get; set; }
    public T? Data { get; set; }
    
    public static ApiResponse<T> Fail(string code, string message)
    {
        return new ApiResponse<T>
        {
            Success = false,
            Code = code,
            Message = message,
            Data = default
        };
    }
}
```

### HTTP状态码映射

| 异常类型 | HTTP状态码 | 错误代码 | 说明 |
|---------|-----------|---------|------|
| ValidationException | 400 | VALIDATION_ERROR | 数据验证失败 |
| UnauthorizedAccessException | 401 | UNAUTHORIZED | 认证失败 |
| ArgumentException | 400 | BAD_REQUEST | 参数错误 |
| InvalidOperationException | 400 | BUSINESS_ERROR | 业务逻辑错误 |
| Exception | 500 | INTERNAL_ERROR | 系统内部错误 |

## 🔧 最佳实践

### 1. Controller层错误处理

**✅ 推荐做法：** 让异常自然抛出，由中间件统一处理

```csharp
[HttpPut("profile")]
public async Task<ActionResult<ApiResponse<string>>> UpdateProfileAsync([FromBody] UpdateUserProfileCommand command)
{
    // 直接调用，让ValidationBehavior处理验证
    await mediator.Send(command);
    return Ok(ApiResponse<string>.Ok("OK", "更新成功"));
}
```

**❌ 不推荐做法：** 在Controller中重复处理异常

```csharp
[HttpPut("profile")]
public async Task<ActionResult<ApiResponse<string>>> UpdateProfileAsync([FromBody] UpdateUserProfileCommand command)
{
    try
    {
        await mediator.Send(command);
        return Ok(ApiResponse<string>.Ok("OK", "更新成功"));
    }
    catch (ValidationException ex) // 重复处理，不推荐
    {
        return BadRequest(ApiResponse<string>.Fail("VALIDATION_ERROR", ex.Message));
    }
}
```

### 2. Service层错误处理

**✅ 推荐做法：** 抛出具体的业务异常

```csharp
public async Task<Guid> RegisterAsync(RegisterUserCommand command)
{
    // 业务验证
    if (await userRepository.ExistsByEmailAsync(command.Email))
        throw new InvalidOperationException("邮箱已存在");
        
    if (await userRepository.ExistsByUserNameAsync(command.UserName))
        throw new InvalidOperationException("用户名已存在");
        
    // 业务逻辑...
}
```

### 3. 验证器错误信息

**✅ 推荐做法：** 提供清晰的中文错误信息

```csharp
public class UpdateUserProfileCommandValidator : AbstractValidator<UpdateUserProfileCommand>
{
    public UpdateUserProfileCommandValidator()
    {
        RuleFor(x => x.Gender)
            .InclusiveBetween(0, 2)
            .WithMessage("性别只能是 0（男）、1（女）或 2（未知）");
            
        RuleFor(x => x.Email)
            .EmailAddress()
            .When(x => !string.IsNullOrWhiteSpace(x.Email))
            .WithMessage("邮箱格式不正确");
            
        RuleFor(x => x.Phone)
            .Matches(@"^1[3-9]\d{9}$")
            .When(x => !string.IsNullOrWhiteSpace(x.Phone))
            .WithMessage("手机号格式不正确");
    }
}
```

## 🔧 故障排除

### 问题：message为空

**症状：**
```json
{
  "success": false,
  "code": "VALIDATION_ERROR",
  "message": "",
  "data": null
}
```

**原因：** `ValidationException`没有正确包含`Errors`集合

**解决方案：**
1. 确保`ValidationBehavior`中抛出异常时传递`failures`集合：
   ```csharp
   throw new ValidationException(failures);  // ✅ 正确
   ```
   
2. 不要只传递消息字符串：
   ```csharp
   throw new ValidationException("验证失败");  // ❌ 错误
   ```

### 问题：验证器没有执行

**症状：** 即使输入无效数据，也没有收到验证错误

**原因：** 验证器没有正确注册或Command没有实现`IRequest`

**解决方案：**
1. 检查Command是否实现了`IRequest`或`IRequest<TResponse>`
2. 检查验证器是否正确注册（使用程序集注册）
3. 检查Controller是否使用`mediator.Send()`调用

## 🧪 测试错误处理

### 1. 测试验证错误

```bash
# 发送包含无效数据的请求
curl -X PUT "http://localhost:5000/api/user/profile" \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{
    "email": "invalid-email",
    "gender": -1,
    "phone": "123456789"
  }'
```

**预期响应：**
```json
{
  "success": false,
  "code": "VALIDATION_ERROR",
  "message": "邮箱格式不正确; 性别只能是 0（男）、1（女）或 2（未知）; 手机号格式不正确",
  "data": null
}
```

### 2. 测试认证错误

```bash
# 不提供Token或使用无效Token
curl -X GET "http://localhost:5000/api/user/profile"
```

**预期响应：**
```json
{
  "success": false,
  "code": "UNAUTHORIZED",
  "message": "用户未认证",
  "data": null
}
```

### 3. 测试业务错误

```bash
# 尝试注册已存在的邮箱
curl -X POST "http://localhost:5000/api/auth/register" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "existing@example.com",
    "password": "Password123",
    "confirmPassword": "Password123"
  }'
```

**预期响应：**
```json
{
  "success": false,
  "code": "BUSINESS_ERROR",
  "message": "邮箱已存在",
  "data": null
}
```

## 📚 前端集成

### 1. 错误处理示例

```javascript
// 前端错误处理示例
async function updateUserProfile(profileData) {
  try {
    const response = await fetch('/api/user/profile', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify(profileData)
    });
    
    const result = await response.json();
    
    if (!result.success) {
      // 显示错误信息
      showError(result.message);
      return;
    }
    
    // 处理成功响应
    showSuccess(result.message);
  } catch (error) {
    console.error('请求失败:', error);
    showError('网络错误，请稍后重试');
  }
}
```

### 2. 错误信息显示

```javascript
function showError(message) {
  // 将错误信息显示给用户
  // 可以是toast、alert或其他UI组件
  console.error('错误:', message);
  
  // 示例：使用toast显示错误
  toast.error(message);
}

function showSuccess(message) {
  // 显示成功信息
  toast.success(message);
}
```

## 🎯 总结

### 错误处理流程

1. **请求进入** → Controller接收请求
2. **验证阶段** → ValidationBehavior执行FluentValidation验证
3. **业务处理** → Handler执行业务逻辑
4. **异常捕获** → GlobalExceptionMiddleware捕获所有异常
5. **错误响应** → 统一格式返回错误信息给前端

### 关键优势

- **统一处理**：所有异常都在中间件中统一处理
- **清晰格式**：使用统一的ApiResponse格式
- **中文友好**：错误信息使用中文，便于用户理解
- **类型安全**：不同类型的异常有不同的错误代码
- **易于调试**：详细的日志记录便于问题排查

### 错误信息传递路径

```
FluentValidation → ValidationBehavior → GlobalExceptionMiddleware → 前端
业务逻辑异常 → Handler → GlobalExceptionMiddleware → 前端
系统异常 → 任意位置 → GlobalExceptionMiddleware → 前端
```

通过这种设计，所有的错误信息都能正确传递到前端，为用户提供清晰的反馈！

## 📚 相关文档

- [MediatR与FluentValidation集成](06_MediatR与FluentValidation集成.md) - 了解验证机制
- [BuildingBlocks通用组件库](02_BuildingBlocks.md) - 了解中间件实现
- [Identity身份认证服务](05_IdentityService.md) - 完整的服务实现
